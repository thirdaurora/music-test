<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
	
加粗：class="add-weight"
代码框：class="code-style"
小代码：class="add-code"
用pre.code-style包着xmp




<h2>随念</h2>
<p>前几天在逛简书时，无意中浏览到了一个百度音乐试听的API，响应的数据是一个JSONP，寻思着最近都在投简历和看书，没怎么写过代码，所以花了点时间写个配合API的数据页面写个音乐页面。</p>
<h2>下载地址：</h2>
<p><a href="http://www.thirdaurora.me/static/download/休闲风音乐页.rar" download>下载（6.4KB）</a><br/>由于百度试听对API对来源设置的限制，在未定义的域中引用（我的网站）是被限制的，所以想要体验，需要下载到本地打开页面。</p>
<h2>技术点</h2>
<ul>
	<li>JSONP的请求与callback</li>
	<li>事件代理</li>
	<li>HTML5———audio、localStorage</li>
	<li>函数防抖</li>
</ul>
<h2>插件</h2>
<p><a href="https://github.com/daneden/animate.css" target="_blank">animate动画库（github）</a></p>
<h3>JSONP的请求与callback</h3>
<p>JSONP是利用<span class="add-code">script</span>标签可以访问其他域的JS文件的原理来实现跨域，写好回调函数，异步插入script标签后得到响应数据，如百度试听API：<br/>
第一步: 在HTML页面中写好回调函数<br/>
第二部：异步插入script标签，如:
<xmp class="code-style"><script src="http://tingapi.ting.baidu.com/v1/restserver
/ting?method=baidu.ting.search.catalogSug&query= 搜索歌曲名 &callback= 写好的回调函数名">
</script></xmp>
第三部：在回调函数中可以操作得到的数据
</p>
<h3>事件代理</h3>
<p>事件代理是把子元素的事件绑定在父元素，由父元素来监听所有由子元素在冒泡阶段传递上来的事件触发。它给大大方便了我们对大量子元素监听的事件绑定，减少因for循环绑定导致的内存泄漏发生的几率，如：</p>
<pre class="code-style">
	一般绑定事件在子元素（为方便用0级DOM事件来演示）:
	const _li = document.getElementsByTagName("li");
	for(let i=0;i<_li.length;i++) {
		_li[i].onclick = () => {
			console.log(i);
		}
	}

	而用了事件代理后：
	const _ul = document.getElementsByTagName("ul")[0];
	_ul.onclick = (e) => {		 //绑定在li的父元素上
		e = e || window.event;
		const target = e.target || e.srcElement;
		if(target.nodeName.toLowerCase() == "li") {
			console.log(target);
		}else if(target.nodeName.toLowerCase() == "p") {
			console.log(target);
		}
	}
	相信看完后你也知道区别了，父元素可以代理所有子元素的事件，而且绑定仅仅需要几行
	代码，无需循环；
</pre>
<h3>HTML5———audio、localStorage</h3>
<p><span class="add-code">audio</span>是HTML新标签，用法简单：
<xmp class="code-style">
<audio src="地址.mp3" autoplay(加载完自动播放)
 controls(显示控件)>如果浏览器不支持audio，会显示这段话</audio>
</xmp>
</p>
<p><span class="add-code">localStorage</span>是一种新的存储方法，它的特点是本地存储，没有时间限制：</p>
<pre class="code-style">
	第一次创建:
		if(localStorage.test) {
			localStorage.test = "123";   //一般数据
			localStorage.test = JSON.stringify([]); 
			//Object 或者 Array
		}
	读取:
		localStorage.test   //一般数据
		JSON.parse(localStorage.test) //Object 或者 Array
	修改：
		localStorage.test = "321"   //一般数据
		 //Object 或者 Array
		 let data = JSON.parse(localStorage.test);
		 data.push(...);
		 JSON.stringify(data);
	删除:
		localStorage.removeItem('test');
</pre>
<h4>localStorage的不足与不同:</h4>
<ul>
	<li>IE8+才支持</li>
	<li>限定为string，其他数据需要转换，所有才有上面的两种不同的方法</li>
	<li>在浏览器隐私模式读取不了</li>
	<li>不能被爬虫抓取，意味着SEO搜索引擎不会爬到它</li>
	<li>与sessionStorage相比，它数据不会被清空，而sessionStorage会，安全性低</li>
</ul>
<h3>函数防抖</h3>
<p>函数防抖指的是多次触发事件后，事件处理函数只执行一次，而且是在事件触发操作停止的时候。如我这次demo的函数防抖实现代码：</p>
<pre class="code-style">
	const _input = document.getElementsByTagName("input")[0];
	let eventTime;
	_input.onkeyup () => {
		var that = this;
		// 每次触发keyup键盘事件都是取消，上一次的搜索事件
		clearTimeout(eventTime);
		// 设置搜索事件, 1S后如果没取消便执行
		eventTime = setTimeout(function(){
			dosomething...
		}, 1000);
	}
</pre>














</body>
</html>